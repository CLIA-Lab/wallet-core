# Notes about Bitcoin

## Wallet
### Private Key
The private key is a number between 1 and $1158 \cdot 10^{77} - 1$ (exclusive). We generate it by applying the following
algorithm from *Mastering Bitcoin*:

1. A random string of 25 characters is generated by successively picking random characters from a fixed string. The character
is selected by applying the `Int()` function from the `crypto/rand` package.
2. SHA256 hash algorithm is applied to the string to obtain 32 bytes of data.
3. The bytes are taking as a big-endian representation of a number. If this number is greater than 0 and less than 
$1158 \cdot 10^{77} - 1$, then it's returned; otherwise, execution goes back to the step 1.

A new private key can be generated by calling the `NewPrivateKey()` function.

WIF is a format for representing private keys. It's obtained by prepending the byte $0x80$ to the private key bytes and
performing a Base58Check encoding to the result.
```go
func ExamplePrivateKey_ToWif() {
    privateKey := NewPrivateKeyFromHex("905e986484cd97da5fc593d061e3610684147f7f1133d509b8334e13b052ded9")
    fmt.Println(privateKey.ToWif())
    // Output:
    // 5JusJkqHvemE1KWEoCZP7tp2DdZgUXVoDdkPvPk1VqCNEi586pi
}
```

### Public Key
The public key $K$ of a private key $k$ is the result of $K = k \cdot G$, where $G$ is the generator point of the elliptic curve
`secp256k1`. $k \cdot G$ means $G + G + ... + G$, $k$ times, where adding two points is equivalent to draw a line between those points,
and reflect the tangent point in the $x$-axis. Therefore, the public key is a point of the elliptic curve.

The coordinates of the $G$ point, as well as the rest of parameters of `secp256k1`,
can be found in the `init()` function of `publicKey.go`.

`secp256k1` is defined by the function 
$$y^2 \mod p = (x^3 + 7) \mod p,$$

where 
$$p = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$$
is a prime number.

The public key of a private key can be obtained by the `GetPublicKey()` function.
```go
func ExampleGetPublicKey() {
    privateKey := NewPrivateKeyFromHex("905e986484cd97da5fc593d061e3610684147f7f1133d509b8334e13b052ded9")
    publicKey := GetPublicKey(privateKey)
    xHex := hex.EncodeToString(publicKey.X[:])
    yHex := hex.EncodeToString(publicKey.Y[:])

    fmt.Println("x =", xHex)
    fmt.Println("y =", yHex)
    // Output:
    // x = ca167032d15483f557426b662dd06c54511ea7616ed9e4020647d49644962e86
    // y = 7a1be4b4be273838766153a2bce2d7eb746be27591fd38cd145a7fe72ad3f425
}
```

Let $K = (x, y)$. The *uncompressed* form of a public key is obtained by prepending the byte $0x04$ to the $64$-bytes 
concatenation of $x$ and $y$. Such a form takes 65 bytes. Compare the following example to the one above.
```go
func ExamplePublicKey_ToUncompressedHex() {
    privateKey := NewPrivateKeyFromHex("905e986484cd97da5fc593d061e3610684147f7f1133d509b8334e13b052ded9")
    fmt.Println(publicKey.ToUncompressedHex())
    // Output:
    // 04ca167032d15483f557426b662dd06c54511ea7616ed9e4020647d49644962e867a1be4b4be273838766153a2bce2d7eb746be27591fd38cd145a7fe72ad3f425
}
```
On the other hand, the *compressed* form is obtained by prepending the byte $0x02$ or the byte $0x03$ to $x$. Which to choose is
determined by the parity of $y$: $0x02$ if $y$ is even, $0x03$ otherwise. Note that given the value of $x$ and the parity of $y$, 
the $y$ value can be computed by applying the elliptic curve formula. That's the theory behind the compressed form. The
*compressed* form, therefore, is 33-bytes long.
```go
func ExamplePublicKey_ToCompressedHex() {
    privateKey := NewPrivateKeyFromHex("905e986484cd97da5fc593d061e3610684147f7f1133d509b8334e13b052ded9")
    publicKey := GetPublicKey(privateKey)
    fmt.Println(publicKey.ToCompressedHex())
    // Output:
    // 03ca167032d15483f557426b662dd06c54511ea7616ed9e4020647d49644962e86
}
```

### Address
The bitcoin address is obtained from the public key by running two hash algorithms: SHA256 and RIPEMD160. The result is a 20-bytes
number:
$$A = RIPEMD160(SHA256(K))$$
where $K$ is the public key and $A$ is the resulting address.

Note the form of $A$ depends on the form of $K$, i.e., if we double-hash the uncompressed form of $K$ we get an address number 
different from double-hashing the compressed form of the same public key $K$. So we can get different addresses for the same
private key. <!-@TODO explain this further by talking about the WIF and WIF-compressed-->
```go
func ExampleGetAddress() {
    privateKey := NewPrivateKeyFromHex("905e986484cd97da5fc593d061e3610684147f7f1133d509b8334e13b052ded9")
    address := GetAddress(GetPublicKey(privateKey))
    compressedHex, uncompressedHex := address.ToHex()
    fmt.Println("compressed:", compressedHex)
    fmt.Println("uncompressed:", uncompressedHex)
    // Output:
    // compressed: ac4f7adb3fbd6bdc140bc32b412aa0e1de48f467
    // uncompressed: 8786fbdf5e88853046aba38fbbc8cf8d314f894e
}
```